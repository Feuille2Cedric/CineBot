import asyncio
import random
import re
import datetime
import discord
from discord.ext import commands, tasks

from function_helpers.constants import (
    PROPOSAL_CHANNEL_ID, VALIDATED_CHANNEL_ID, COMMANDS_CHANNEL_ID, UPDATE_CHANNEL_ID,
    QUIZ_ROLE_ID, CHECKS_REQUIRED, QUESTIONS_PAR_JOUR,
    HOUR_QUESTIONS_DAILY, MINUTE_QUESTIONS_DAILY,
)
from function_helpers import db as dbh
from function_helpers import utils as U

class QuizCog(commands.Cog, name="QuizCog"):
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        # d√©marrer la t√¢che quotidienne si pas d√©j√† lanc√©e
        if not self.daily_questions.is_running():
            self.daily_questions.start()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Events ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    @commands.Cog.listener()
    async def on_message(self, message: discord.Message):
        if message.author.bot:
            return

        if message.channel.id == PROPOSAL_CHANNEL_ID:
            content = message.content.strip()
            question, reponse = U.extract_question_reponse(content)
            if question and reponse:
                if not U.is_spoiler(reponse):
                    await message.channel.send(
                        "‚ùå Merci de mettre la r√©ponse en spoiler Discord, par exemple : `R: ||ma r√©ponse||`"
                    )
                    return
                try:
                    await message.add_reaction('‚úÖ')
                except Exception:
                    pass

        await self.bot.process_commands(message)

    @commands.Cog.listener()
    async def on_reaction_add(self, reaction: discord.Reaction, user: discord.User):
        if user.bot:
            return

        # exclusivit√© de r√©actions ‚úÖ ‚ùå üöÆ
        exclusive_emojis = ['‚úÖ', '‚ùå', 'üöÆ']
        if str(reaction.emoji) in exclusive_emojis:
            message = reaction.message
            for react in message.reactions:
                if (str(react.emoji) in exclusive_emojis
                    and str(react.emoji) != str(reaction.emoji)):
                    users = [u async for u in react.users() if not u.bot]
                    if user in users:
                        try:
                            await message.remove_reaction(react.emoji, user)
                        except Exception as e:
                            print(f"Erreur retrait reaction: {e}")

        # Suppression via üöÆ
        if str(reaction.emoji) == 'üöÆ':
            try:
                if reaction.message.channel.id in [VALIDATED_CHANNEL_ID, COMMANDS_CHANNEL_ID]:
                    users = [u async for u in reaction.users() if not u.bot]
                    print(f"[DEBUG] üöÆ votes sur {reaction.message.id} : {[u.id for u in users]}")
                    if len(users) >= 3:
                        content = reaction.message.content
                        match = re.search(r"\*\*Question :\*\* (.+?)\n\|\|", content, re.DOTALL)
                        if match:
                            question_text = match.group(1).strip()
                            async with self.bot.db.acquire() as conn:
                                await conn.execute("DELETE FROM questions WHERE question = $1", question_text)
                            await reaction.message.channel.send(
                                f"üóëÔ∏è La question ¬´ {question_text} ¬ª a √©t√© supprim√©e apr√®s signalement."
                            )
                        else:
                            await reaction.message.channel.send(
                                "Impossible de trouver le texte de la question pour la suppression."
                            )
            except Exception as e:
                print(f"Erreur suppression via üöÆ : {e}")

        # Validation des propositions via ‚úÖ
        if reaction.message.channel.id == PROPOSAL_CHANNEL_ID and str(reaction.emoji) == '‚úÖ':
            users = [u async for u in reaction.users() if not u.bot]
            if len(users) == CHECKS_REQUIRED:
                content = reaction.message.content
                question, reponse = U.extract_question_reponse(content)
                if question and reponse:
                    if not U.is_spoiler(reponse):
                        await reaction.message.channel.send(
                            "‚ùå Merci de mettre la r√©ponse en spoiler Discord, par exemple : `R: ||ma r√©ponse||`"
                        )
                        return
                    if not question.endswith("?"):
                        question += " ?"
                    answer_text = reponse[2:-2].strip()
                    rows = await self.bot.db.fetch("SELECT 1 FROM questions WHERE question = $1", question)
                    if not rows:
                        await dbh.save_question(self.bot.db, question, answer_text)
                        await reaction.message.channel.send(
                            f"‚úÖ Nouvelle question ajout√©e √† la base !\n**Q:** {question}\n**R:** ||{answer_text}||"
                        )
                    else:
                        await reaction.message.channel.send("Cette question existe d√©j√† dans la base de donn√©es.")
                elif "Proposition de question :" in content and "R√©ponse :" in content:
                    question = content.split("Proposition de question :")[1].split("\n")[0].strip()
                    reponse = content.split("R√©ponse :")[1].split("||")[1].strip()
                    rows = await self.bot.db.fetch("SELECT 1 FROM questions WHERE question = $1", question)
                    if not rows:
                        await dbh.save_question(self.bot.db, question, reponse)
                        validated_channel = self.bot.get_channel(VALIDATED_CHANNEL_ID)
                        if validated_channel:
                            await validated_channel.send(f"Question valid√©e : {question}\nR√©ponse : ||{reponse}||")
                        await reaction.message.channel.send("Question ajout√©e √† la base de donn√©es !")
                    else:
                        await reaction.message.channel.send("Cette question existe d√©j√† dans la base de donn√©es.")

        # Enregistrement du score quotidien via r√©actions
        if reaction.message.channel.id == VALIDATED_CHANNEL_ID:
            if reaction.message.content.startswith(f"<@&{QUIZ_ROLE_ID}> Indiquez votre score"):
                emoji_to_score = {
                    '0Ô∏è‚É£': 0,'1Ô∏è‚É£': 1,'2Ô∏è‚É£': 2,'3Ô∏è‚É£': 3,'4Ô∏è‚É£': 4,'5Ô∏è‚É£': 5,
                    '6Ô∏è‚É£': 6,'7Ô∏è‚É£': 7,'8Ô∏è‚É£': 8,'9Ô∏è‚É£': 9,'üîü': 10,
                }
                if str(reaction.emoji) in emoji_to_score:
                    score = emoji_to_score[str(reaction.emoji)]
                    day = await dbh.get_day_count(self.bot.db)
                    await dbh.save_score(self.bot.db, user.id, day, 1, score, [])
                    print(f"[DEBUG] Score enregistr√© : user={user.id}, day={day}, score={score}")

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Commandes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    @commands.command()
    async def propose(self, ctx, *, question_et_reponse: str):
        if ctx.channel.id != PROPOSAL_CHANNEL_ID:
            await ctx.send("Vous devez proposer les questions dans le salon appropri√©.")
            return
        if "|" not in question_et_reponse:
            await ctx.send("Format attendu : question | r√©ponse")
            return
        question, reponse = [part.strip() for part in question_et_reponse.split("|", 1)]
        msg = await ctx.send(
            f"Proposition de question : {question}\nR√©ponse : ||{reponse}||\n\nAjoutez ‚úÖ pour valider !"
        )
        await msg.add_reaction('‚úÖ')

    @commands.command()
    async def q(self, ctx):
        if ctx.channel.id != COMMANDS_CHANNEL_ID:
            await ctx.send("Cette commande n'est autoris√©e que dans le salon de commandes.")
            return
        row = await dbh.get_random_question(self.bot.db)
        if not row:
            await ctx.send("Aucune question disponible.")
            return
        msg = await ctx.send(f"**Question :** {row['question']}\n||{row['answer']}||")
        for e in ('‚úÖ', '‚ùå', 'üöÆ'):
            await msg.add_reaction(e)

    @commands.command()
    async def sp(self, ctx):
        scores = await dbh.get_scores(self.bot.db)
        user_id = str(ctx.author.id)
        now = datetime.datetime.now()
        daily = weekly = monthly = total = correct = total_questions = 0

        for day_str, data in scores.get(user_id, {}).items():
            day_num = int(day_str)
            day_date = U.day_to_date(day_num)
            if day_date == now.date():
                daily += data["score"]
            if day_date.isocalendar()[1] == now.isocalendar()[1] and day_date.year == now.year:
                weekly += data["score"]
            if day_date.month == now.month and day_date.year == now.year:
                monthly += data["score"]
            total += data["score"]
            correct += data["score"]
            total_questions += QUESTIONS_PAR_JOUR

        precision = (correct / total_questions * 100) if total_questions else 0

        # leaderboard global
        leaderboard = []
        for uid, days in scores.items():
            t = sum(d["score"] for d in days.values())
            leaderboard.append((uid, t))
        leaderboard.sort(key=lambda x: x[1], reverse=True)
        rank = next((i+1 for i, v in enumerate(leaderboard) if v[0] == user_id), None)

        embed = discord.Embed(
            title=f"Profil de {ctx.author.name} üìä",
            color=discord.Color.blue()
        )
        embed.set_thumbnail(url=ctx.author.display_avatar.url)
        embed.add_field(name="üìÖ Score quotidien", value=f"{daily} points", inline=False)
        embed.add_field(name="üìÜ Score hebdomadaire", value=f"{weekly} points", inline=False)
        embed.add_field(name="üóìÔ∏è Score mensuel", value=f"{monthly} points", inline=False)
        embed.add_field(name="üèÜ Score total", value=f"{total} points", inline=False)
        embed.add_field(name="üéØ Pr√©cision", value=f"{precision:.2f}%", inline=False)
        embed.add_field(name="üíØ Total de questions r√©pondues", value=f"{total_questions} questions", inline=False)
        if rank:
            embed.set_footer(text=f"Tu es class√© #{rank} total avec {total} points !")
        await ctx.send(embed=embed)

    @commands.command()
    async def sr(self, ctx, *, mode: str = "weekly"):
        now = datetime.datetime.now()
        embed = discord.Embed()
        leaderboard = {}
        rows = await self.bot.db.fetch("SELECT user_id, day, score FROM scores_daily")

        mode_clean = mode.lower().replace(" ", "")
        if mode_clean == "alltime":
            for row in rows:
                uid = str(row["user_id"])
                leaderboard[uid] = leaderboard.get(uid, 0) + row["score"]
            embed.title = "üèÖ Classement Global ‚Äì Tous Temps"
            embed.color = discord.Color.purple()
        else:
            current_week = now.isocalendar()[1]
            current_year = now.year
            for row in rows:
                day_date = U.day_to_date(row["day"])
                if day_date.isocalendar()[1] == current_week and day_date.year == current_year:
                    uid = str(row["user_id"])
                    leaderboard[uid] = leaderboard.get(uid, 0) + row["score"]
            embed.title = "üèÜ Classement Weekly üèÜ"
            embed.color = discord.Color.gold()

        sorted_lb = sorted(leaderboard.items(), key=lambda x: x[1], reverse=True)
        desc = ""
        for i, (uid, score) in enumerate(sorted_lb[:20], 1):
            try:
                user = await self.bot.fetch_user(int(uid))
                name = user.name
            except Exception:
                name = f"Utilisateur {uid}"
            desc += f"**{i}**. {name} ‚Äî **{score} points**\n"
        embed.description = desc

        user_id = str(ctx.author.id)
        user_rank = next((i+1 for i, v in enumerate(sorted_lb) if v[0] == user_id), None)
        user_score = leaderboard.get(user_id, 0)
        if user_rank:
            suffix = "au total" if mode_clean == "alltime" else "cette semaine"
            embed.set_footer(text=f"{ctx.author.name} est class√© #{user_rank} {suffix} avec {user_score} points.")
        await ctx.send(embed=embed)

    @commands.command()
    async def annonce_nouveautes(self, ctx):
        if ctx.channel.id != UPDATE_CHANNEL_ID:
            await ctx.send("Cette commande ne peut √™tre utilis√©e que dans le fil d√©di√©.")
            return

        quiz_role_mention = f"<@&{QUIZ_ROLE_ID}>"
        embed = discord.Embed(
            title="üì¢ Mise √† jour du Bot Quiz Cin√©ma",
            description="De nouvelles fonctionnalit√©s viennent d‚Äôarriver pour am√©liorer votre exp√©rience ! üé¨üçø",
            color=0x1ABC9C
        )
        embed.add_field(
            name="üìÖ 10 questions le dimanche",
            value="Le quiz quotidien propose 10 questions le dimanche, pour pimenter la fin de semaine !",
            inline=False
        )
        embed.add_field(
            name="‚ôªÔ∏è Pas de r√©p√©tition de questions",
            value="Les questions d√©j√† pos√©es ne reviendront pas avant d‚Äôavoir √©puis√© tout le stock.",
            inline=False
        )
        embed.add_field(
            name="üìä Commande `!sr alltime` & `!sr all time`",
            value="Affiche le classement global de tous les temps. `!sr` reste le classement hebdomadaire.",
            inline=False
        )
        embed.add_field(
            name="üöÆ Suppression de questions par vote",
            value=(
                "Un nouvel emoji üöÆ a √©t√© ajout√© sur chaque question.\n"
                "Apr√®s 5 votes utilisateurs, la question est supprim√©e de la base."
            ),
            inline=False
        )
        embed.add_field(
            name="üìå Rappel des commandes cl√©s",
            value=(
                "`!q` - Question al√©atoire\n"
                "`!sp` - Tes statistiques\n"
                "`!sr` - Classement hebdo\n"
                "`!sr alltime` ou `!sr all time` - Classement global\n"
                "`!propose question | r√©ponse` - Propose ta question"
            ),
            inline=False
        )
        embed.set_footer(text="Amusez-vous bien et merci pour votre participation !")

        await ctx.send(quiz_role_mention)
        await ctx.send(embed=embed)

    @commands.command(name="aide")
    async def help_cmd(self, ctx):
        embed = discord.Embed(
            title="Aide du bot Quiz Cin√©ma",
            color=discord.Color.green()
        )
        embed.add_field(name="!q", value="Affiche une question cin√©ma al√©atoire.", inline=False)
        embed.add_field(name="!sp", value="Affiche ton profil et tes statistiques.", inline=False)
        embed.add_field(name="!sr", value="Affiche le classement hebdomadaire.", inline=False)
        embed.add_field(
            name="!propose question | r√©ponse",
            value="Propose une nouvelle question (ou utilise le format Q: ... R: ... ou Q : ... R : ...).",
            inline=False
        )
        embed.add_field(
            name="Quiz quotidien",
            value="R√©agis avec l‚Äôemoji correspondant √† ton score sous le message du quiz pour enregistrer tes points.",
            inline=False
        )
        await ctx.send(embed=embed)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ T√¢che quotidienne ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    @tasks.loop(hours=24)
    async def daily_questions(self):
        await self.bot.wait_until_ready()
        channel = self.bot.get_channel(VALIDATED_CHANNEL_ID)

        # 0 = Lundi, 6 = Dimanche
        today_weekday = datetime.datetime.now().weekday()
        nb_questions = 10 if today_weekday == 6 else QUESTIONS_PAR_JOUR

        questions = await dbh.get_unused_questions(self.bot.db)
        if len(questions) < nb_questions:
            await dbh.reset_used_questions(self.bot.db)
            questions = await dbh.get_unused_questions(self.bot.db)

        if len(questions) < nb_questions:
            await channel.send(f"Pas assez de questions pour le quiz du jour ({nb_questions} n√©cessaires) !")
            return

        day = await dbh.get_day_count(self.bot.db) + 1
        await dbh.set_day_count(self.bot.db, day)

        intro_msg = await dbh.get_jour_message(self.bot.db, day)
        await channel.send(intro_msg)

        selected = random.sample(questions, nb_questions)
        await dbh.mark_questions_used(self.bot.db, [q['id'] for q in selected])

        for q in selected:
            msg = await channel.send(f"**Question :** {q['question']}\n||{q['answer']}||")
            await msg.add_reaction('‚úÖ')
            await msg.add_reaction('‚ùå')
            await msg.add_reaction('üöÆ')
            await asyncio.sleep(2)

        msg = await channel.send(f"<@&{QUIZ_ROLE_ID}> Indiquez votre score du jour en r√©agissant ci-dessous :")
        score_emojis = (
            ['0Ô∏è‚É£','1Ô∏è‚É£','2Ô∏è‚É£','3Ô∏è‚É£','4Ô∏è‚É£','5Ô∏è‚É£','6Ô∏è‚É£','7Ô∏è‚É£','8Ô∏è‚É£','9Ô∏è‚É£','üîü']
            if today_weekday == 6
            else ['0Ô∏è‚É£','1Ô∏è‚É£','2Ô∏è‚É£','3Ô∏è‚É£','4Ô∏è‚É£','5Ô∏è‚É£']
        )
        for emoji in score_emojis:
            await msg.add_reaction(emoji)

    @daily_questions.before_loop
    async def before_daily_questions(self):
        now = datetime.datetime.now()
        target = now.replace(hour=HOUR_QUESTIONS_DAILY,
                             minute=MINUTE_QUESTIONS_DAILY,
                             second=0, microsecond=0)
        if target < now:
            target += datetime.timedelta(days=1)
        wait_seconds = (target - now).total_seconds()
        print(f"[DEBUG] Attente de {wait_seconds:.0f} secondes avant le prochain quiz quotidien ({target})")
        await asyncio.sleep(wait_seconds)

# ‚îÄ‚îÄ export ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def setup(bot):
    # Emp√™che un double ajout si reload/bug r√©seau
    if bot.get_cog("QuizCog") is None:
        from commands.quiz_cog import QuizCog  # si d√©fini plus haut c'est d√©j√† import√©
        await bot.add_cog(QuizCog(bot))
